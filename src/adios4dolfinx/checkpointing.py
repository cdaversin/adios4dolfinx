import argparse
import time

import adios2
import numpy as np
from mpi4py import MPI
import basix
import dolfinx
import ufl


__all__ = ["read_mesh_from_legacy_checkpoint", "write_mesh"]


def compute_local_range(comm: MPI.Comm, N: int):
    rank = comm.rank
    size = comm.size
    n = N // size
    r = N % size
    # First r processes has one extra value
    if rank < r:
        return [rank*(n+1), (rank+1)*(n+1)]
    else:
        return [rank*n+r, (rank+1)*n + r]


def read_mesh_from_legacy_checkpoint(filename: str, celltype: str = "tetrahedron") -> dolfinx.mesh.Mesh:
    """
    Read mesh from `h5`-file generated by legacy DOLFIN `XDMFFile.write_checkpoint`.
    Needs to get the `cell_type` as input, as legacy DOLFIN does not store the cell-type in the 
    `h5`-file

    Args:
        filename: Path to `h5` file (with extension)
        celltype: String describing cell-type    
    """

    adios = adios2.ADIOS(MPI.COMM_WORLD)
    io = adios.DeclareIO("Mesh reader")
    io.SetEngine("HDF5")

    # Open ADIOS2 Reader
    infile = io.Open(filename, adios2.Mode.Read)

    # Get mesh topology (distributed)
    if f"{args.path}/topology" not in io.AvailableVariables().keys():
        raise KeyError(f"Mesh topology not found at '{args.path}topology'")
    topology = io.InquireVariable(f"{args.path}/topology")
    shape = topology.Shape()
    local_range = compute_local_range(MPI.COMM_WORLD, shape[0])
    topology.SetSelection([[local_range[0], 0], [
                          local_range[1]-local_range[0], shape[1]]])

    mesh_topology = np.empty(
        (local_range[1]-local_range[0], shape[1]), dtype=np.int32)
    infile.Get(topology, mesh_topology, adios2.Mode.Sync)

    # NOTE: XDMFFile.write_checkpoint does not write all information in h5 file, would need to fetch
    # info regarding celltype from h5 file

    # Get mesh cell type
    # if f"{args.path}/topology/celltype" not in io.AvailableAttributes().keys():
    #     raise KeyError(
    #         f"Mesh cell type not found at '{args.path}/topology/celltype'")
    # celltype = io.InquireAttribute(f"{args.path}/topology/celltype")
    cell_type = "tetrahedron"  # celltype.DataString()[0]

    # Get mesh geometry
    if f"{args.path}/geometry" not in io.AvailableVariables().keys():
        raise KeyError(
            f"Mesh geometry not found at '{args.path}/geometry'")
    geometry = io.InquireVariable(f"{args.path}/geometry")
    shape = geometry.Shape()
    local_range = compute_local_range(MPI.COMM_WORLD, shape[0])
    geometry.SetSelection([[local_range[0], 0], [
                          local_range[1]-local_range[0], shape[1]]])
    mesh_geometry = np.empty(
        (local_range[1]-local_range[0], shape[1]), dtype=np.float64)
    infile.Get(geometry, mesh_geometry, adios2.Mode.Sync)
    end = time.perf_counter()

    assert adios.RemoveIO("Mesh reader")

    # end = time.perf_counter()

    # Create DOLFINx mesh
    element = basix.ufl_wrapper.create_vector_element(
        basix.ElementFamily.P, cell_type, 1, basix.LagrangeVariant.equispaced,
        dim=mesh_geometry.shape[1], gdim=mesh_geometry.shape[1])
    domain = ufl.Mesh(element)

    return dolfinx.mesh.create_mesh(
        MPI.COMM_WORLD, mesh_topology, mesh_geometry, domain)


def write_mesh(mesh: dolfinx.mesh.Mesh, filename: str, engine: str = "BP4"):
    """
    Write a mesh to specified ADIOS2 format, see: https://adios2.readthedocs.io/en/stable/engines/engines.html
    for possible formats.

    Args:
        mesh: The mesh to write to file
        filename: Path to save mesh (without file-extension)
        engine: Adios2 Engine
    """
    comm = mesh.comm
    local_points = mesh.geometry.x
    num_xdofs_local = mesh.geometry.index_map().size_local
    num_xdofs_global = mesh.geometry.index_map().size_local
    local_range = mesh.geometry.index_map().local_range

    gdim = mesh.geometry.dim

    adios = adios2.ADIOS(mesh.comm)
    io = adios.DeclareIO("MeshWriter")
    io.SetEngine("HDF5")
    file = "outfile.h5"
    outfile = io.Open(file, adios2.Mode.Write)

    # Write geometry
    pointvar = io.DefineVariable(
        "Points", local_points[:num_xdofs_local, :], shape=[num_xdofs_global, local_points.shape[1]],
        start=[local_range[0], 0], count=[num_xdofs_local, local_points.shape[1]])
    outfile.Put(pointvar, local_points[:num_xdofs_local, :])

    # Write celltype
    io.DefineAttribute("CellType", mesh.topology.cell_name())

    # Write topology
    g_imap = mesh.geometry.index_map()
    g_dmap = mesh.geometry.dofmap
    l_start = g_imap.local_range[0]
    num_cells_local = mesh.topology.index_map(mesh.topology.dim).size_local
    num_cells_global = mesh.topology.index_map(
        mesh.topology.dim).size_global
    start_cell = mesh.topology.index_map(mesh.topology.dim).local_range[0]
    geom_layout = mesh.geometry.cmap.create_dof_layout()
    num_dofs_per_cell = geom_layout.num_entity_closure_dofs(
        mesh.geometry.dim)

    dofs_out = np.zeros(
        (num_cells_local, num_dofs_per_cell), dtype=np.int64)
    dofs_out[:, :] = g_dmap.array[:num_cells_local *
                                  num_dofs_per_cell].reshape(num_cells_local, num_dofs_per_cell) + l_start

    dvar = io.DefineVariable(
        "Dofmap", dofs_out, shape=[num_cells_global, num_dofs_per_cell],
        start=[start_cell, 0], count=[num_cells_local, num_dofs_per_cell])
    outfile.Put(dvar, dofs_out)
    outfile.PerformPuts()
    assert adios.RemoveIO("MeshWriter")
